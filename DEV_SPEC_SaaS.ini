DEV_SPEC_SaaS.md — 「AI名刺」SaaS（マルチテナント）実装仕様
0. 要約 / 目的

名刺のQR/NFCから開くパブリック名刺ページにAIエージェント（OpenAI）が常駐し、自己紹介／サービス説明／簡易見積／リード獲得／決済リンク提示まで実施。

**SaaS（マルチテナント）**として、組織（テナント）ごとに複数の「AI名刺（カード）」を発行。Stripe Billingでサブスク課金。

管理画面（ダッシュボード）で：プロフィール・料金ルール・事例・CTA（予約URL/Stripeリンク）・QR生成・ドメイン設定を編集可能。

UIkit 3で素早く実装（将来Tailwind等へ置換可能）。

1. 推奨スタック / バージョン

Next.js 14+（App Router） + TypeScript

UIkit 3（CDN）＋ 最小の自前CSS

Supabase（Postgres + Auth + RLS + Edge Functions任意）

Stripe Billing（月額プラン/無料枠付与）

OpenAI（gpt-4o-mini推奨）

Upstash Redis（任意：Rate Limit/KV。Supabaseでも可）

Sentry（任意：監視）

Playwright（E2E）

Zod（API入力バリデーション）

2. マルチテナント設計

テナント（organizations）：複数ユーザー、複数カードを保持。

ユーザー（users）：Supabase Auth（Email/Password or OAuth）。membershipsでorgに所属・役割。

カード（cards）：公開URL/{handle}/c/{cardSlug}で表示（将来サブドメイン cardname.例.com に拡張可）。

課金（subscriptions）：Stripe Customer=org単位。free → proへアップグレード。

3. URL設計

パブリック名刺：https://app.example.com/{orgHandle}/c/{cardSlug}

ダッシュボード：/dashboard（org切替可）

初期オンボーディング：/onboarding → org作成 → 初回カード作成 → QR生成

4. データモデル（Supabase / SQL）

すべてRLS有効。org_idでテナント分離。

-- 4.1 organizations（テナント）
create table if not exists public.organizations (
  id uuid primary key default gen_random_uuid(),
  handle text unique not null check (handle ~ '^[a-z0-9-]{3,30}$'),
  name text not null,
  created_at timestamptz default now()
);

-- 4.2 users（Supabaseのauth.usersを利用）…アプリ側メタはprofilesへ
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  created_at timestamptz default now()
);

-- 4.3 memberships（ユーザー↔組織）
create type public.role as enum ('owner','admin','editor','viewer');
create table if not exists public.memberships (
  org_id uuid references public.organizations(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  role public.role not null default 'editor',
  primary key (org_id, user_id),
  created_at timestamptz default now()
);

-- 4.4 billing（Stripe連携）
create table if not exists public.billing (
  org_id uuid primary key references public.organizations(id) on delete cascade,
  stripe_customer_id text,
  stripe_subscription_id text,
  plan text not null default 'free',
  status text not null default 'active',
  current_period_end timestamptz
);

-- 4.5 cards（AI名刺カード）
create table if not exists public.cards (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.organizations(id) on delete cascade,
  slug text not null,
  title text not null,
  avatar_url text,
  persona text, -- AIの話法やトーン
  bio text,
  services text, -- 改行区切り or MD
  calendar_url text,
  stripe_payment_link text,
  brand_color text default '#316B3F',
  is_active boolean default true,
  created_at timestamptz default now(),
  unique (org_id, slug)
);

-- 4.6 pricing_rules（JSON）
create table if not exists public.pricing_rules (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.organizations(id) on delete cascade,
  card_id uuid references public.cards(id) on delete cascade,
  rules jsonb not null, -- { "wordpress_site": { "base": 150000, "options": {...} } }
  created_at timestamptz default now()
);

-- 4.7 leads（リード保存）
create table if not exists public.leads (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.organizations(id) on delete cascade,
  card_id uuid not null references public.cards(id) on delete cascade,
  name text not null,
  email text not null,
  message text,
  estimate_total int,
  created_at timestamptz default now()
);

-- 4.8 events（計測）
create table if not exists public.events (
  id bigserial primary key,
  org_id uuid not null references public.organizations(id) on delete cascade,
  card_id uuid references public.cards(id) on delete cascade,
  session_id text,
  name text not null, -- view/chat.start/chat.reply/quote/cta/lead
  payload jsonb,
  ip inet,
  created_at timestamptz default now()
);

-- RLS: org_id で分離（抜粋）
alter table organizations enable row level security;
alter table memberships enable row level security;
alter table cards enable row level security;
alter table pricing_rules enable row level security;
alter table leads enable row level security;
alter table events enable row level security;

-- RLSポリシー例（memberships に基づく読み書き）
create policy org_read on cards for select
  using (exists (select 1 from memberships m where m.org_id = cards.org_id and m.user_id = auth.uid()));
create policy org_write on cards for all
  using (exists (select 1 from memberships m where m.org_id = cards.org_id and m.user_id = auth.uid() and m.role in ('owner','admin','editor')));

-- パブリック閲覧（名刺ページ）用（selectのみ）:
create policy public_card_read on cards for select using (is_active = true);
create policy public_pricing_read on pricing_rules for select using (
  exists(select 1 from cards c where c.id = pricing_rules.card_id and c.is_active = true)
);


注意：パブリックURLでselectのみ許すため、anonキーで読み取り可のRLSを上記のように定義。書き込みは匿名不可。

5. Stripe課金モデル

free：カード1枚、月1,000メッセージまで、リード保存可、決済リンク1つ。

pro：カード無制限、月50,000メッセージ、優先レート、カスタムドメイン（将来）。

Stripe要素：Product（plan_free, plan_pro）、Webhook（customer.subscription.*, checkout.session.completed）

デフォルト：サインアップ→org作成時にfree付与。プロへはCheckout/Customer Portalで変更。

6. API設計（Next.js Route Handlers）

共通仕様：

入力は Zod でバリデーション（400を返す）。

エラーは構造化JSON { ok:false, code, message }。

IP Rate Limit：IP×org×window（Upstash or Supabase）。

監査ログ：eventsへ非同期 insert。

6.1 POST /api/chat

概要：カードとナレッジを読み、OpenAIで応答を生成

入力：

{
  "orgHandle": "panolabo",
  "cardSlug": "numa",
  "messages": [{"role":"user","content":"飲食店向けの料金は？"}],
  "lang": "ja",
  "sessionId": "uuid"
}


出力：

{
  "ok": true,
  "reply": "WordPressサイトは15万円〜…",
  "nextActions": [
    {"type":"estimate","label":"見積もりを計算"},
    {"type":"lead","label":"相談を送る"},
    {"type":"checkout","label":"Stripeで支払う","url":"..."}
  ]
}

6.2 POST /api/estimate

概要：pricing_rules.rulesに基づきサーバ側で合計算出

入力：

{
  "orgHandle":"panolabo",
  "cardSlug":"numa",
  "items":[{"key":"wordpress_site","options":["seo","multilang"]}]
}


出力：

{
  "ok": true,
  "currency": "JPY",
  "breakdown": [{"key":"wordpress_site","base":150000,"options":[{"seo":30000},{"multilang":50000}],"subtotal":230000}],
  "total": 230000,
  "paymentLink": "https://buy.stripe.com/..."
}

6.3 POST /api/lead

概要：問い合わせ保存＋通知（メールは任意）

入力：

{"orgHandle":"panolabo","cardSlug":"numa","name":"田中","email":"t@example.com","message":"来月までに"}


出力：{"ok": true, "leadId": "uuid"}

6.4 POST /api/stripe/webhook

概要：サブスク更新/キャンセル反映

入力：Stripe Webhook（署名検証）

出力：200 OK（幂等）

7. プロンプト設計

system（テンプレ）：

あなたは {orgName} の営業アシスタントAIです。口調は {persona}。
目的：相手の文脈に合わせ、サービス内容を最短で理解→行動（見積/リード/決済/予約）へ導く。
制約：与えられたナレッジ（bio/services/pricing_rules/disclaimer）の範囲で回答。不明な点は推測せず質問。
出力：1〜3文＋必要なら箇条書き。価格は参考レンジ。誇大表現はしない。


context：cards（bio/services/stripe_link/calendar）＋ pricing_rules.rules をJSONで埋め込み
user：ユーザー入力メッセージ

8. フロントエンド（UIkit 3）
8.1 公開ページ（最小）

ページ：app/[orgHandle]/c/[cardSlug]/page.tsx

セクション：プロフィールカード、チャットログ、入力欄、CTAボタン（見積／相談／Stripe／予約）、QRダイアログ

アクセシビリティ：ライブリージョン、Enter送信、Shift+Enter改行

8.2 ダッシュボード

カード一覧／編集（bio/services/persona/brand_color/CTA）

料金ルールJSONエディタ（Monacoなど）＋プリセット（WPサイト/アプリ/OEM）

リード一覧（CSV出力）

イベント簡易グラフ（view→lead率）

9. レート制限 / セキュリティ

Rate Limit：[(orgHandle, cardSlug, ip)] で 1分あたり N 回（.envで設定）

CORS：同一オリジンのみ（公開ページ内のAPI呼び出し）

CSRF：POSTのみ、SameSite=Laxのセッションクッキーで保護（Supabase Auth）

RLS：前述のポリシー。匿名selectのみ許容するテーブル限定。

Webhook：Stripe署名検証必須

10. 監視 / ログ

APIエラーはconsole.error＋Sentry（任意）

eventsへ非同期 insert（パフォーマンス担保のためtx外）

11. .env.sample
# Next
NEXT_PUBLIC_APP_URL=https://ai-card.example.com
NEXT_PUBLIC_UIKIT_CSS=https://cdn.jsdelivr.net/npm/uikit@3.17.10/dist/css/uikit.min.css
NEXT_PUBLIC_UIKIT_JS=https://cdn.jsdelivr.net/npm/uikit@3.17.10/dist/js/uikit.min.js

# Supabase
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
SUPABASE_SERVICE_ROLE_KEY=...

# OpenAI
OPENAI_API_KEY=sk-...
OPENAI_MODEL=gpt-4o-mini
OPENAI_TIMEOUT_MS=20000

# Stripe
STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...
NEXT_PUBLIC_STRIPE_PRICE_PRO=price_...

# Rate Limit
RATE_LIMIT_PER_MINUTE=20

# Sentry (optional)
SENTRY_DSN=

12. 最小可動コード（コピペ用）

① Next.js で新規App Routerプロジェクトを作成し、以下のファイルを追加してください。
② Supabaseで上記SQLを流し、RLSを有効化。
③ StripeでProduct/Priceを作成・env設定。
④ Vercelにデプロイ。

12.1 app/[orgHandle]/c/[cardSlug]/page.tsx
// 最小の公開名刺ページ（UIkit 3 前提）
// - プロフィール表示
// - チャットUI（/api/chat へPOST）
// - 見積ボタン（/api/estimate）・相談ボタン（/api/lead）
// 例外処理/エッジケースに配慮した最小構成

import { Metadata } from "next";
import Script from "next/script";
import React from "react";

export const dynamic = "force-dynamic";

export async function generateMetadata(
  { params }: { params: { orgHandle: string; cardSlug: string } }
): Promise<Metadata> {
  const title = `${params.cardSlug} | ${params.orgHandle} - AI名刺`;
  return { title, description: "AIエージェント名刺" };
}

export default function Page({ params }: { params: { orgHandle: string; cardSlug: string } }) {
  return (
    <>
      {/* UIkit CDN（envで差し替え） */}
      <link rel="stylesheet" href={process.env.NEXT_PUBLIC_UIKIT_CSS} />
      <Script src={process.env.NEXT_PUBLIC_UIKIT_JS!} strategy="afterInteractive" />

      <div className="uk-section uk-section-default">
        <div className="uk-container">
          <div className="uk-card uk-card-default uk-card-body">
            <h1 className="uk-heading-line"><span>AI Business Card</span></h1>
            <div className="uk-text-meta">AIがご案内します</div>

            <div id="chat-log" className="uk-margin-small" style={{maxHeight:'45vh', overflowY:'auto', background:'#fafafa', padding:8}} />
            <div className="uk-flex uk-margin">
              <input id="chat-input" className="uk-input" placeholder="ご用件（例：料金、事例、OEMは？）" />
              <button id="chat-send" className="uk-button uk-button-primary uk-margin-left">送信</button>
            </div>

            <div className="uk-margin">
              <button className="uk-button" data-action="estimate">見積り試算</button>
              <button className="uk-button" data-action="lead">相談を送る</button>
            </div>

            <hr />
            <div className="uk-text-small uk-text-muted">
              価格は参考です。確定見積はヒアリング後にご提示します。
            </div>
          </div>
        </div>
      </div>

      <script
        dangerouslySetInnerHTML={{
          __html: `
          (function(){
            const org = ${JSON.stringify(params.orgHandle)};
            const card = ${JSON.stringify(params.cardSlug)};
            const log = document.getElementById('chat-log');
            const input = document.getElementById('chat-input');
            const send = document.getElementById('chat-send');
            const buttons = document.querySelectorAll('[data-action]');
            const messages = [];

            function append(role, text){
              const div = document.createElement('div');
              div.className = role === 'user' ? 'uk-alert-success' : 'uk-alert-primary';
              div.setAttribute('uk-alert','');
              div.textContent = text;
              log.appendChild(div);
              log.scrollTop = log.scrollHeight;
            }

            async function post(path, body){
              const res = await fetch(path, {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify(body)
              });
              return await res.json();
            }

            async function callChat(userText){
              messages.push({role:'user', content:userText});
              append('user', userText);
              send.disabled = true;
              try{
                const data = await post('/api/chat', {
                  orgHandle: org, cardSlug: card, messages: messages, lang:'ja', sessionId: crypto.randomUUID()
                });
                if(!data.ok){ append('ai', 'エラー：'+(data.message||'unknown')); return; }
                append('ai', data.reply || '…');
              }catch(e){
                append('ai', '通信に失敗しました');
              }finally{ send.disabled = false; }
            }

            send.addEventListener('click', ()=>{
              const t = input.value.trim(); if(!t) return; input.value=''; callChat(t);
            });
            input.addEventListener('keydown', (e)=> { if(e.key==='Enter') send.click(); });

            buttons.forEach(btn=>{
              btn.addEventListener('click', async ()=>{
                const action = btn.dataset.action;
                if(action==='estimate'){
                  const data = await post('/api/estimate', { orgHandle: org, cardSlug: card,
                    items:[{key:'wordpress_site', options:['seo']}] });
                  if(!data.ok){ append('ai','見積りエラー'); return; }
                  let txt = '概算見積り（'+data.currency+'）\\n';
                  data.breakdown.forEach(b=>{ txt += '- '+b.key+': 小計 '+b.subtotal.toLocaleString()+'円\\n'; });
                  txt += '合計: '+data.total.toLocaleString()+'円';
                  if(data.paymentLink) txt += '\\n支払い: '+data.paymentLink;
                  append('ai', txt);
                }
                if(action==='lead'){
                  const name = prompt('お名前'); const email = prompt('メールアドレス'); const message = prompt('ご相談内容（任意）')||'';
                  if(!name || !email){ append('ai','入力が不足しています'); return; }
                  const data = await post('/api/lead', { orgHandle: org, cardSlug: card, name, email, message });
                  append('ai', data.ok ? 'ありがとうございます。担当よりご連絡します。' : '送信に失敗しました');
                }
              });
            });
          })();
        `}}
      />
    </>
  );
}

12.2 app/api/chat/route.ts
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

// OpenAI SDK無しでfetch呼び出し（軽量化）
const OPENAI_API = "https://api.openai.com/v1/chat/completions";
const MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
const OPENAI_API_KEY = process.env.OPENAI_API_KEY!;

const Schema = z.object({
  orgHandle: z.string().min(3),
  cardSlug: z.string().min(1),
  messages: z.array(z.object({ role: z.string(), content: z.string() })).min(1),
  lang: z.string().optional(),
  sessionId: z.string().optional()
});

async function loadCard(orgHandle: string, cardSlug: string) {
  // 実装：Supabaseクエリ（RLSのpublic selectでis_activeのみ取得）
  // ここではダミー値を返す。Claude Codeに実装させる
  return {
    orgName: orgHandle, title: cardSlug,
    bio: "Web歴30年。AI×WP×OEMで成果直結。",
    services: "WordPress/アプリ/AI副業サポート/OEM",
    persona: "フレンドリーで即断・即決を促す営業トーン",
    stripePaymentLink: "",
    pricingRules: {
      wordpress_site: { base: 150000, options: { seo: 30000, multilang: 50000 } },
      mobile_app: { base: 100000, options: { map: 15000 } }
    }
  };
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const parse = Schema.safeParse(body);
    if (!parse.success) return NextResponse.json({ ok:false, code:"bad_request", message: parse.error.message }, { status:400 });

    const { orgHandle, cardSlug, messages } = parse.data;
    // TODO: レート制限（IP+org+card）
    const card = await loadCard(orgHandle, cardSlug);
    if (!card) return NextResponse.json({ ok:false, code:"not_found", message:"card not found" }, { status:404 });

    const system = [
      `あなたは ${card.orgName} の営業アシスタントAIです。口調は ${card.persona}。`,
      `目的：相手の文脈に合わせ、サービス理解→行動（見積/リード/決済/予約）へ導く。`,
      `制約：与えられたナレッジの範囲で回答。不明は推測せず質問。`,
      `--- ナレッジ ---`,
      `bio: ${card.bio}`,
      `services: ${card.services}`,
      `pricing_rules: ${JSON.stringify(card.pricingRules, null, 2)}`
    ].join("\n");

    const payload = {
      model: MODEL,
      messages: [{ role:"system", content: system }, ...messages],
      temperature: 0.4
    };

    const res = await fetch(OPENAI_API, {
      method: "POST",
      headers: {
        "Content-Type":"application/json",
        "Authorization": `Bearer ${OPENAI_API_KEY}`
      },
      body: JSON.stringify(payload),
      // タイムアウト短め（Envで調整）
      signal: AbortSignal.timeout(Number(process.env.OPENAI_TIMEOUT_MS || 20000))
    });

    if (!res.ok) {
      const t = await res.text();
      return NextResponse.json({ ok:false, code:"llm_error", message:t.slice(0,200) }, { status:500 });
    }

    const data = await res.json();
    const reply = data?.choices?.[0]?.message?.content || "回答を生成できませんでした。";

    const nextActions = [
      { type:"estimate", label:"見積もりを計算" },
      { type:"lead", label:"相談を送る" },
      ...(card.stripePaymentLink ? [{ type:"checkout", label:"Stripeで支払う", url: card.stripePaymentLink }] : [])
    ];

    // TODO: 非同期でeventsへinsert
    return NextResponse.json({ ok:true, reply, nextActions });
  } catch (e:any) {
    return NextResponse.json({ ok:false, code:"server_error", message: e?.message || "unknown" }, { status:500 });
  }
}

12.3 app/api/estimate/route.ts
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

const Schema = z.object({
  orgHandle: z.string().min(3),
  cardSlug: z.string().min(1),
  items: z.array(z.object({ key: z.string(), options: z.array(z.string()).optional() })).min(1)
});

function calcTotal(rules: any, items: any[]) {
  let breakdown:any[] = [], total = 0;
  for (const it of items) {
    const r = rules[it.key]; if (!r) continue;
    const base = Number(r.base||0);
    let sum = base; const opts:any[] = [];
    for (const o of (it.options||[])) {
      const val = Number(r.options?.[o]||0);
      if (val>0) { opts.push({[o]:val}); sum += val; }
    }
    breakdown.push({ key: it.key, base, options: opts, subtotal: sum });
    total += sum;
  }
  return { breakdown, total };
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const parse = Schema.safeParse(body);
    if (!parse.success) return NextResponse.json({ ok:false, code:"bad_request", message: parse.error.message }, { status:400 });

    // TODO: Supabaseからpricing_rulesを取得（RLS public select）
    const rules = {
      wordpress_site: { base: 150000, options:{ seo:30000, multilang:50000 } },
      mobile_app: { base: 100000, options:{ map:15000 } }
    };

    const { breakdown, total } = calcTotal(rules, parse.data.items);
    const paymentLink = ""; // TODO: cards.stripe_payment_link をlookup

    return NextResponse.json({ ok:true, currency:"JPY", breakdown, total, paymentLink, note:"価格は参考見積です。" });
  } catch (e:any) {
    return NextResponse.json({ ok:false, code:"server_error", message: e?.message || "unknown" }, { status:500 });
  }
}

12.4 app/api/lead/route.ts
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

const Schema = z.object({
  orgHandle: z.string().min(3),
  cardSlug: z.string().min(1),
  name: z.string().min(1),
  email: z.string().email(),
  message: z.string().optional(),
  estimate_total: z.number().optional()
});

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const parse = Schema.safeParse(body);
    if (!parse.success) return NextResponse.json({ ok:false, code:"bad_request", message: parse.error.message }, { status:400 });

    // TODO: Supabaseへinsert（RLS: public書込み不可ならEdge Function経由にする）
    // ここはPoCとしてOKレスだけ返す
    return NextResponse.json({ ok:true, leadId: "mock-uuid" });
  } catch (e:any) {
    return NextResponse.json({ ok:false, code:"server_error", message: e?.message || "unknown" }, { status:500 });
  }
}

12.5 app/api/stripe/webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import Stripe from "stripe";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

export async function POST(req: NextRequest) {
  const sig = req.headers.get("stripe-signature");
  const whSecret = process.env.STRIPE_WEBHOOK_SECRET!;
  let event: Stripe.Event;

  try {
    const buf = await req.arrayBuffer();
    const text = Buffer.from(buf).toString("utf8");
    event = stripe.webhooks.constructEvent(text, sig!, whSecret);
  } catch (err:any) {
    return NextResponse.json({ ok:false, message:`Webhook Error: ${err.message}` }, { status:400 });
  }

  try {
    switch (event.type) {
      case "checkout.session.completed":
      case "customer.subscription.created":
      case "customer.subscription.updated":
      case "customer.subscription.deleted":
        // TODO: org_idに対応するstripe_customer_idを検索し、billingテーブルを更新
        break;
    }
    return NextResponse.json({ ok:true });
  } catch (e:any) {
    return NextResponse.json({ ok:false, message:e?.message || "unknown" }, { status:500 });
  }
}

13. オンボーディング / 管理UI（要件）

/onboarding：org作成 → handle/社名 → 初回カード作成 → 料金ルールプリセット（WP/アプリ/OEM）選択 → 完了で/{org}/c/{slug}発行。

/dashboard：

Cards：一覧/新規/編集（bio/services/persona/brand/CTA/公開ON/OFF）

Pricing：JSONエディタ＋プリセットボタン

Leads：一覧/CSVエクスポート

Billing：現在プラン／アップグレード（Stripe Customer Portal）

14. QA / テスト

単体：入出力Zodバリデーション、見積計算（係数/オプション）

結合：chat→OpenAI失敗時のフォールバック文言、estimate→ルール欠落時の0円表示＋注意

E2E（Playwright）：

公開ページで質問→AI応答

見積試算→合計表示

相談送信→成功トースト

レート超過→エラーメッセージ

Webhookモック→プラン変更反映

15. デプロイ手順（Vercel / Supabase / Stripe）

Supabase：上記SQLをSQLエディタに貼付。RLS有効化。

Stripe：Product/Price作成、Webhookエンドポイントに/api/stripe/webhookを登録（Signing Secret控える）。

Env：.envをVercel/Supabaseに設定（上記サンプル）。

Vercel：vercel deploy。ドメイン割当。

初期データ：organizations/membershipsにオーナーを作り、ダッシュボードにログインできるようにする（Supabase Auth）。

16. セキュリティ / エッジケース

OpenAIキー欠落：chatは即 503（「準備中」メッセージ）

Stripeリンク未設定：checkout CTAは非表示

RLS確認：anonがselect以外できないことを必ずテスト

Rate Limit：RATE_LIMIT_PER_MINUTE超過で429 JSON

入力検証：Zodで型/長さ/メール妥当性

ログ：PIIをevents.payloadに直接保存しない（leadは別テーブル）

17. 受け入れ基準（ローンチ条件）

/{org}/c/{card}の公開ページでQ&A/見積/リードが完動。

Stripe free→proのアップグレードがUIから完了し、billing.planが更新。

RLS/Rate/CORS/Webhook署名など主要セキュリティが機能。

主要エラーが意味のあるメッセージでハンドリングされる。

最低限の運用ダッシュボード（カード編集/料金JSON/リード一覧）。

付録A：料金ルールプリセット（JSON）
{
  "wordpress_site": { "base": 150000, "options": { "seo": 30000, "multilang": 50000, "speed": 20000 } },
  "mobile_app": { "base": 100000, "options": { "map": 15000, "push": 20000, "subscription": 30000 } },
  "oem": { "base": 200000, "options": { "white_label": 30000 } }
}

付録B：公開ページUI（UIkitの推奨クラス）

メッセージ：uk-alert-primary（AI）, uk-alert-success（User）

ボタン：uk-button uk-button-primary／uk-button

レイアウト：uk-section / uk-container / uk-card